const chai = require('chai');
const chaiHttp = require('chai-http');
const jwt = require('jsonwebtoken');

// eslint-disable-next-line no-unused-vars
const should = chai.should();

const app = require('../../app/server');

const mongoDB = require('../../app/services/mongodb-service');
const Contest = require('../factories/contest');
const Entrant = require('../factories/entrant');
const User = require('../factories/user-factory');
const { COLLECTIONS } = require('../../app/utils/constant');


chai.use(chaiHttp);

describe('Delete Lineup Tests', () => {
  const user = User.create();
  const contestDate = new Date();
  contestDate.setDate(contestDate.getDate() + 1);
  const startedContest = Contest.create(contestDate, true, true);
  const anotherStartedContest = Contest.create(contestDate, true, true);


  const entrantForStartedContest = Entrant.create(startedContest, true);
  const entrantForanotherStartedContest = Entrant.create(anotherStartedContest, true);
  const submittedEntrant = Entrant.create(anotherStartedContest, false);

  let userId = null;
  let entrantForStartedContestId = null;
  let entrantForanotherStartedContestId = null;
  let submittedEntrantId = null;

  before((done) => {
    mongoDB.connect().then(() => {
      mongoDB.dbInstance().dropDatabase(() => {
        mongoDB.dbInstance().collection(COLLECTIONS.USERS)
          .insertOne(user, (error, userResult) => {
            if (error) done(error);
            userId = userResult.insertedId;
            entrantForStartedContest.userId = userId;
            mongoDB.dbInstance().collection(COLLECTIONS.CONTESTS).insertMany(
              [startedContest, anotherStartedContest], (err) => {
                if (err) done(err);
                mongoDB.dbInstance().collection(COLLECTIONS.ENTRANTS).insertMany(
                  [entrantForStartedContest, entrantForanotherStartedContest, submittedEntrant],
                  (entrantErr, entrantResult) => {
                    if (entrantErr) done(entrantErr);
                    entrantForStartedContestId = entrantResult.ops[0]._id;
                    entrantForanotherStartedContestId = entrantResult.ops[1]._id;
                    submittedEntrantId = entrantResult.ops[2]._id;
                    done();
                  },
                );
              },
            );
          });
      });
    });
  });

  it('returns status as 404 when no lineup is found', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).delete(`/users/lineups/${entrantForanotherStartedContestId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(404);
        result.body.message.should.equal('Unable to delete Lineup.');
        result.body.code.should.equal('lineup.delete.failed');
        done();
      });
  });

  it('returns status as 403 when it tries to delete submitted Lineup', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).delete(`/users/lineups/${submittedEntrantId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(403);
        result.body.message.should.equal('Unable to delete submitted lineup.');
        result.body.code.should.equal('lineup.delete.forbidden.submitted');
        done();
      });
  });

  it('returns status as 200 when lineup gets deleted successfully', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).delete(`/users/lineups/${entrantForStartedContestId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(200);
        result.body.message.should.equal('Lineup deleted successfully.');
        result.body.code.should.equal('lineup.deleted');
        done();
      });
  });
});
