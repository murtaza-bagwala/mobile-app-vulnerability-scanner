const chai = require('chai');
const chaiHttp = require('chai-http');
const jwt = require('jsonwebtoken');

// eslint-disable-next-line no-unused-vars
const should = chai.should();

const app = require('../../app/server');

const mongoDB = require('../../app/services/mongodb-service');
const Contest = require('../factories/contest');
const Entrant = require('../factories/entrant');
const User = require('../factories/user-factory');
const { COLLECTIONS } = require('../../app/utils/constant');


chai.use(chaiHttp);

describe('Update Lineup Tests', () => {
  const contest = Contest.create(new Date(), true, true);
  const draftedContest = Contest.create(new Date(), false, false);
  const user = User.create();
  const contestDate = new Date();
  contestDate.setDate(contestDate.getDate() + 1);
  const futureContest = Contest.create(contestDate, true, false);
  const currentContest = Contest.create(new Date(), true, false);

  const entrant = Entrant.create(contest, true);
  const submittedEntrant = Entrant.create(contest);
  const entrantForFutureContest = Entrant.create(futureContest, true);
  const entrantForCurrentContest = Entrant.create(currentContest, true);
  const entrantForDradftedContest = Entrant.create(draftedContest, true);

  let userId = null;

  let entrantId = null;
  let entrantForFutureContestId = null;
  let entrantForCurrentContestId = null;
  let entrantForDradftedContestId = null;
  let submittedEntrantId = null;

  before((done) => {
    mongoDB.connect().then(() => {
      mongoDB.dbInstance().dropDatabase(() => {
        mongoDB.dbInstance().collection(COLLECTIONS.CONTESTS).insertMany(
          [contest, draftedContest, futureContest, currentContest], (err) => {
            if (err) done(err);
            mongoDB.dbInstance().collection(COLLECTIONS.ENTRANTS).insertMany(
              [entrant, entrantForDradftedContest,
                entrantForFutureContest, entrantForCurrentContest,
                submittedEntrant],
              (entrantErr, entrantResult) => {
                if (entrantErr) done(entrantErr);
                entrantId = entrantResult.ops[0]._id;
                entrantForDradftedContestId = entrantResult.ops[1]._id;
                entrantForFutureContestId = entrantResult.ops[2]._id;
                entrantForCurrentContestId = entrantResult.ops[3]._id;
                submittedEntrantId = entrantResult.ops[4]._id;
                mongoDB.dbInstance().collection(COLLECTIONS.USERS)
                  .insertOne(user, (error, userResult) => {
                    if (error) done(error);
                    userId = userResult.insertedId;
                    done();
                  });
              },
            );
          },
        );
      });
    });
  });

  it('returns status as 403 if lineup is already submited', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).put(`/users/lineups/${submittedEntrantId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(403);
        result.body.message.should.equal('Unable to update submitted lineup.');
        result.body.code.should.equal('lineup.update.forbidden.submitted');
        done();
      });
  });

  it('returns status as 403 if contest is already started', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).put(`/users/lineups/${entrantId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(403);
        result.body.message.should.equal('You cannot join a contest after it has started.');
        result.body.code.should.equal('contest.started');
        done();
      });
  });

  it('returns status as 403 if entries are closed', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).put(`/users/lineups/${entrantForDradftedContestId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(403);
        result.body.message.should.equal('Entries are closed for this contest. Please check for new contests.');
        result.body.code.should.equal('contest.closed.entries');
        done();
      });
  });

  it('returns status as 403 if entries are yet to be opened', (done) => {
    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).put(`/users/lineups/${entrantForFutureContestId}`)
      .set('Authorization', `Bearer ${token}`)
      .send()
      .end((err, result) => {
        result.should.have.status(403);
        result.body.message.should.equal('This draft has not opened yet!.');
        result.body.code.should.equal('contest.opened.not.entries');
        done();
      });
  });

  it('returns status as 200 if lineup is updated', (done) => {
    const lineupParams = {
      entryFee: 100,
      currencyIsoCode: 'USD',
      selectedNumber: 100,
      isDrafted: true,
    };

    const token = jwt.sign({ sub: userId }, process.env.SECRET_KEY, { expiresIn: '1h' });

    chai.request(app).put(`/users/lineups/${entrantForCurrentContestId}`)
      .set('Authorization', `Bearer ${token}`)
      .send(lineupParams)
      .end((err, result) => {
        result.should.have.status(200);
        result.body.updatedLineup.isDrafted.should.equal(true);
        result.body.updatedLineup.amount.should.equal(lineupParams.entryFee);
        result.body.updatedLineup.targetNumber.should.equal(lineupParams.selectedNumber);
        result.body.code.should.equal('lineup.updated');
        done();
      });
  });
});
